#!/usr/bin/env bash
# Memoriter run script: sets up virtual environment and runs create_summary.
# Edit the parameters below, then run: ./run
#
# Modes:
#   ./run                          - process default input (psalm_1)
#   INPUT_FILE=all ./run           - loop input/*, create output only for missing
#   INPUT_FILE=path.txt ./run      - process single file (set OUTPUT_NAME for output)

set -e
cd "$(dirname "$0")"

# -----------------------------------------------------------------------------
# Parameters (edit these, or override when running: INPUT_FILE=passage.txt ./run)
# -----------------------------------------------------------------------------
# Read passage from this file. Use "all" to process every file in input/ (missing outputs only).
INPUT_FILE="${INPUT_FILE:-input/psalm_1.txt}"

# Or pass text directly (leave empty if using INPUT_FILE or stdin).
TEXT="${TEXT:-}"

# Save summary to output/OUTPUT_NAME.txt (leave empty to only print). Used for single-file runs.
OUTPUT_NAME="${OUTPUT_NAME:-psalm_1}"

# Set to "yes" to treat entire text as one line (single string of first letters).
NO_STRUCTURE="${NO_STRUCTURE:-no}"
# -----------------------------------------------------------------------------

# Set up virtual environment if missing
if [[ ! -d .venv ]]; then
  echo "Creating virtual environment..."
  python3 -m venv .venv
fi
PYTHON=".venv/bin/python"

# Ensure dependencies and pre-commit hook are installed (idempotent)
"$PYTHON" -m pip install -q -r requirements.txt
"$PYTHON" -m pre_commit install

run_one() {
  local infile="$1"
  local outname="$2"
  local extra=()
  if [[ "$NO_STRUCTURE" = yes ]]; then
    extra=(--no-structure)
  fi
  "$PYTHON" create_summary.py -f "$infile" -o "$outname" "${extra[@]}"
}

if [[ "$INPUT_FILE" = all ]]; then
  # Batch: loop input/*, create output only where missing
  INPUT_DIR="input"
  OUTPUT_DIR="output"
  mkdir -p "$OUTPUT_DIR"
  count=0
  for infile in "$INPUT_DIR"/*; do
    [[ -f "$infile" ]] || continue
    basename="${infile##*/}"
    outname="${basename%.*}"
    outfile="$OUTPUT_DIR/${outname}.txt"
    if [[ ! -f "$outfile" ]]; then
      echo "Creating $outfile (from $infile)"
      run_one "$infile" "$outname"
      count=$((count + 1))
    fi
  done
  echo "Done. Created $count output(s)."
  exit 0
fi

# Single-file run
ARGS=()
if [[ -n "$INPUT_FILE" ]]; then
  ARGS+=(-f "$INPUT_FILE")
fi
if [[ -n "$OUTPUT_NAME" ]]; then
  ARGS+=(-o "$OUTPUT_NAME")
fi
if [[ "$NO_STRUCTURE" = yes ]]; then
  ARGS+=(--no-structure)
fi
if [[ -n "$TEXT" ]]; then
  ARGS+=("$TEXT")
fi

if [[ -z "$INPUT_FILE" && -z "$TEXT" ]]; then
  echo "No input set. Either:"
  echo "  1. Edit the run script and set INPUT_FILE= (e.g. input/psalm_1.txt) or TEXT="
  echo "  2. Run with: INPUT_FILE=input/psalm_1.txt OUTPUT_NAME=psalm_1 ./run"
  echo "  3. Run all (only missing outputs): INPUT_FILE=all ./run"
  echo "  4. Pipe text: echo 'Your passage here' | ./run"
  exit 1
fi

exec "$PYTHON" create_summary.py "${ARGS[@]}"
