#!/usr/bin/env bash
# Memoriter run script: sets up virtual environment and runs create_summary.
# Edit the parameters below, then run: ./run
#
# Modes:
#   ./run                          - process default input (psalm_1)
#   INPUT_FILE=all ./run           - loop input/*, process only inputs with missing output
#   ./run -f                       - process all inputs and regenerate outputs (same as INPUT_FILE=all ./run -f)
#   INPUT_FILE=all ./run -f        - same: force regenerate all outputs
#   INPUT_FILE=path.txt ./run      - process single file (set OUTPUT_NAME for output)

set -e
cd "$(dirname "$0")"

# Parse -f / --force (regenerate all outputs in batch mode)
FORCE=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    -f|--force) FORCE=1; shift ;;
    *) break ;;
  esac
done

# -----------------------------------------------------------------------------
# Parameters (edit these, or override when running: INPUT_FILE=passage.txt ./run)
# -----------------------------------------------------------------------------
# Read passage from this file. Use "all" to process every file in input/. With -f and no INPUT_FILE, defaults to "all".
INPUT_FILE="${INPUT_FILE:-}"
if [[ -z "$INPUT_FILE" && $FORCE -eq 1 ]]; then
  INPUT_FILE=all
elif [[ -z "$INPUT_FILE" ]]; then
  INPUT_FILE="input/psalm_1.txt"
fi

# Or pass text directly (leave empty if using INPUT_FILE or stdin).
TEXT="${TEXT:-}"

# Save summary to output/OUTPUT_NAME.txt (leave empty to only print). Used for single-file runs.
OUTPUT_NAME="${OUTPUT_NAME:-psalm_1}"

# Set to "yes" to treat entire text as one line (single string of first letters).
NO_STRUCTURE="${NO_STRUCTURE:-no}"
# -----------------------------------------------------------------------------

# Set up virtual environment if missing
if [[ ! -d .venv ]]; then
  echo "Creating virtual environment..."
  python3 -m venv .venv
fi
PYTHON=".venv/bin/python"

# Ensure dependencies and pre-commit hook are installed (idempotent)
"$PYTHON" -m pip install -q -r requirements.txt
"$PYTHON" -m pre_commit install

run_one() {
  local infile="$1"
  local outname="$2"
  local extra=()
  if [[ "$NO_STRUCTURE" = yes ]]; then
    extra=(--no-structure)
  fi
  "$PYTHON" create_summary.py -f "$infile" -o "$outname" "${extra[@]}"
}

if [[ "$INPUT_FILE" = all ]]; then
  # Batch: process every file in input/; without -f only when output is missing
  INPUT_DIR="input"
  OUTPUT_DIR="output"
  mkdir -p "$OUTPUT_DIR"
  count=0
  while IFS= read -r -d '' infile; do
    basename="${infile##*/}"
    outname="${basename%.*}"
    outfile="$OUTPUT_DIR/${outname}.txt"
    if [[ $FORCE -eq 1 || ! -f "$outfile" ]]; then
      echo "Processing $infile -> $outfile"
      run_one "$infile" "$outname"
      count=$((count + 1))
    fi
  done < <(find "$INPUT_DIR" -maxdepth 1 -type f -print0 | sort -z)
  echo "Done. Processed $count file(s)."
  exit 0
fi

# Single-file run
ARGS=()
if [[ -n "$INPUT_FILE" ]]; then
  ARGS+=(-f "$INPUT_FILE")
fi
if [[ -n "$OUTPUT_NAME" ]]; then
  ARGS+=(-o "$OUTPUT_NAME")
fi
if [[ "$NO_STRUCTURE" = yes ]]; then
  ARGS+=(--no-structure)
fi
if [[ -n "$TEXT" ]]; then
  ARGS+=("$TEXT")
fi

if [[ -z "$INPUT_FILE" && -z "$TEXT" ]]; then
  echo "No input set. Either:"
  echo "  1. Edit the run script and set INPUT_FILE= (e.g. input/psalm_1.txt) or TEXT="
  echo "  2. Run with: INPUT_FILE=input/psalm_1.txt OUTPUT_NAME=psalm_1 ./run"
  echo "  3. Run all: INPUT_FILE=all ./run"
  echo "  4. Pipe text: echo 'Your passage here' | ./run"
  exit 1
fi

exec "$PYTHON" create_summary.py "${ARGS[@]}"
